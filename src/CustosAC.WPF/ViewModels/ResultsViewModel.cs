using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CustosAC.Core.Models;
using CustosAC.WPF.ViewModels.Base;
using Microsoft.Extensions.DependencyInjection;

namespace CustosAC.WPF.ViewModels;

public partial class ResultsViewModel : ViewModelBase
{
    [ObservableProperty]
    private int _totalFindings;

    [ObservableProperty]
    private bool _hasThreats;

    [ObservableProperty]
    private string _statusText = "CLEAN";

    [ObservableProperty]
    private string _scanDuration = "0.0s";

    [ObservableProperty]
    private ObservableCollection<ResultCategoryViewModel> _categories = new();

    public void LoadResults(List<(string name, ScanResult result)> results)
    {
        Categories.Clear();
        TotalFindings = 0;

        TimeSpan totalDuration = TimeSpan.Zero;

        foreach (var (name, result) in results)
        {
            // Only add categories with findings
            if (result.HasFindings)
            {
                var category = new ResultCategoryViewModel
                {
                    Name = name,
                    IsClean = false,
                    FindingsCount = result.Count,
                    IsExpanded = true // Auto-expand categories with findings
                };

                foreach (var finding in result.Findings)
                {
                    category.Findings.Add(new FindingItem { Path = finding });
                }

                Categories.Add(category);
                TotalFindings += result.Count;
            }

            totalDuration += result.Duration;
        }

        HasThreats = TotalFindings > 0;
        StatusText = HasThreats ? "THREATS DETECTED" : "CLEAN";
        ScanDuration = $"{totalDuration.TotalSeconds:F1}s";
    }

    [RelayCommand]
    private void NewScan()
    {
        var mainVm = App.Services.GetRequiredService<MainViewModel>();
        mainVm.NavigateToDashboardCommand.Execute(null);
    }

    [RelayCommand]
    private async Task ExportText()
    {
        var dialog = new Microsoft.Win32.SaveFileDialog
        {
            Filter = "Text files (*.txt)|*.txt",
            FileName = $"CustosAC_Report_{DateTime.Now:yyyyMMdd_HHmmss}.txt"
        };

        if (dialog.ShowDialog() == true)
        {
            var lines = new List<string>
            {
                "╔══════════════════════════════════════════════════════════════════════════════╗",
                "║                           CUSTOS AC SCAN REPORT                              ║",
                "╚══════════════════════════════════════════════════════════════════════════════╝",
                "",
                $"  Date:           {DateTime.Now:yyyy-MM-dd HH:mm:ss}",
                $"  Duration:       {ScanDuration}",
                $"  Total Findings: {TotalFindings}",
                $"  Status:         {StatusText}",
                "",
                "════════════════════════════════════════════════════════════════════════════════"
            };

            foreach (var cat in Categories)
            {
                lines.Add("");
                lines.Add($"┌─ {cat.Name} ({cat.FindingsCount} found) ─────────────────────────────────────────────");
                lines.Add("│");

                int index = 1;
                foreach (var finding in cat.Findings)
                {
                    lines.Add($"│  [{index:D3}] {finding.Path}");
                    index++;
                }

                lines.Add("│");
                lines.Add("└──────────────────────────────────────────────────────────────────────────────");
            }

            lines.Add("");
            lines.Add("════════════════════════════════════════════════════════════════════════════════");
            lines.Add("                          Generated by custosAC v2.1                            ");
            lines.Add("════════════════════════════════════════════════════════════════════════════════");

            await File.WriteAllLinesAsync(dialog.FileName, lines);
        }
    }

    [RelayCommand]
    private async Task ExportCsv()
    {
        var dialog = new Microsoft.Win32.SaveFileDialog
        {
            Filter = "CSV files (*.csv)|*.csv",
            FileName = $"CustosAC_Report_{DateTime.Now:yyyyMMdd_HHmmss}.csv"
        };

        if (dialog.ShowDialog() == true)
        {
            var lines = new List<string> { "Category,Finding" };

            foreach (var cat in Categories)
            {
                foreach (var finding in cat.Findings)
                {
                    lines.Add($"\"{cat.Name}\",\"{finding.Path.Replace("\"", "\"\"")}\"");
                }
            }

            await File.WriteAllLinesAsync(dialog.FileName, lines);
        }
    }
}

public partial class ResultCategoryViewModel : ObservableObject
{
    [ObservableProperty]
    private string _name = "";

    [ObservableProperty]
    private bool _isClean = true;

    [ObservableProperty]
    private int _findingsCount;

    [ObservableProperty]
    private bool _isExpanded;

    public ObservableCollection<FindingItem> Findings { get; } = new();
}

public partial class FindingItem : ObservableObject
{
    [ObservableProperty]
    private string _path = "";

    public string ShortPath => Path.Length > 60 ? "..." + Path[^57..] : Path;

    public string DisplayPath
    {
        get
        {
            // Extract clean path from various formats
            var path = Path;

            // Remove prefix like [reason]
            if (path.StartsWith("["))
            {
                var closeBracket = path.IndexOf(']');
                if (closeBracket > 0)
                    path = path[(closeBracket + 1)..].Trim();
            }

            // Extract path from "| Path: X" format
            var pathIndex = path.IndexOf("| Path:", StringComparison.OrdinalIgnoreCase);
            if (pathIndex > 0)
            {
                path = path[(pathIndex + 7)..].Trim();
                var nextPipe = path.IndexOf('|');
                if (nextPipe > 0)
                    path = path[..nextPipe].Trim();
            }

            return path;
        }
    }

    [RelayCommand]
    private void OpenFolder()
    {
        try
        {
            var path = DisplayPath;

            // Try to find a valid file/folder path in the string
            if (path.Contains('\\') || path.Contains('/'))
            {
                // Clean up path - extract actual file path
                var cleanPath = ExtractFilePath(path);

                if (!string.IsNullOrEmpty(cleanPath))
                {
                    if (File.Exists(cleanPath))
                    {
                        // Select the file in explorer
                        Process.Start("explorer.exe", $"/select,\"{cleanPath}\"");
                    }
                    else if (Directory.Exists(cleanPath))
                    {
                        // Open the directory
                        Process.Start("explorer.exe", $"\"{cleanPath}\"");
                    }
                    else
                    {
                        // Try parent directory
                        var dir = System.IO.Path.GetDirectoryName(cleanPath);
                        if (!string.IsNullOrEmpty(dir) && Directory.Exists(dir))
                        {
                            Process.Start("explorer.exe", $"\"{dir}\"");
                        }
                    }
                }
            }
        }
        catch
        {
            // Silently fail if path can't be opened
        }
    }

    private static string ExtractFilePath(string text)
    {
        // Try to find a Windows path pattern
        var startIdx = -1;

        // Look for drive letter pattern (C:\, D:\, etc.)
        for (int i = 0; i < text.Length - 2; i++)
        {
            if (char.IsLetter(text[i]) && text[i + 1] == ':' && (text[i + 2] == '\\' || text[i + 2] == '/'))
            {
                startIdx = i;
                break;
            }
        }

        if (startIdx < 0)
        {
            // Look for UNC path (\\server\share)
            var uncIdx = text.IndexOf(@"\\", StringComparison.Ordinal);
            if (uncIdx >= 0)
                startIdx = uncIdx;
        }

        if (startIdx < 0)
            return text;

        // Extract the path until we hit an invalid character or end
        var endIdx = startIdx;
        while (endIdx < text.Length)
        {
            var c = text[endIdx];
            // Stop at characters that likely aren't part of a path
            if (c == '|' || c == '\n' || c == '\r' || c == '\t')
                break;
            endIdx++;
        }

        return text[startIdx..endIdx].Trim();
    }
}
